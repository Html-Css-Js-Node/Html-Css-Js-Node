let mas =['1','2','3','4','5','6','7','8','9',
          '10','11','12','13','14','15','16','17',
          '18','19','20','21','22','23','24',
          '25','26','27','28'] //27 ячеек

let section = document.getElementById("section");

let click = section.getElementsByTagName('li');

for (let i = 0; i < click.length; i ++) {
  
  
  click[i].onclick = function(){


         let id = this.getAttribute("id");

         if(id == mas[0]) {

          document.getElementById('p').innerHTML = 
   `
   <div class="radio_playlist1">
    <ul>Компью́терная программа<br>
     <li>Компью́терная програ́мма — 
        <p>
            1) комбинация компьютерных инструкций и данных, позволяющая аппаратному обеспечению вычислительной системы выполнять вычисления или функции управления (стандарт ISO/IEC/IEEE 24765:2010);<br><br>
            2) синтаксическая единица, которая соответствует правилам определённого языка программирования, состоящая из определений и операторов или инструкций, необходимых для определённой функции, задачи или решения проблемы (стандарт ISO/IEC 2382-1:1993).<br><br>

            Первое определение соответствует понятию «исполняемая программа», второе относится к понятию «исходный текст».
            
           

        </p>
     </li>   



    </ul>
    </div>    
          `;

                }else if (id == mas[1]) {

document.getElementById('p').innerHTML = 

          `
<div class="radio_playlist1">
    <ul>Исполняемый файл<br>
     <li>Исполняемый файл — 
        <p>
         набор инструкций, который заставляет компьютер выполнить определённую задачу. В отличие от текстового файла, который рассчитан на чтение человеком, исполняемый файл рассчитан на чтение (и выполнение) процессором.<br><br>
         Под «инструкциями» традиционно понимается машинный код, который выполняется напрямую физическим процессором. В некоторых случаях файл, содержащий инструкции сценария промежуточного языка программирования (например, байт-код), также может считаться исполняемым.


        </p>
     </li>
     <li>Создание исполняемых файлов
     <p>
     Исполняемые файлы могут быть созданы вручную на машинном языке, но этот подход обычно не используется из-за отсутствия как такового синтаксиса и удобочитаемости кода, поэтому гораздо удобнее разрабатывать исполняемые программы на языке программирования высокого уровня, который доступен для понимания. В некоторых случаях исходный код может быть на языке ассемблера, который остается удобочитаемым, но при этом предназначен для работы с инструкциями машинного кода.<br><br>

Код на языке высокого уровня компилируется в объектные файлы машинного кода, который не является исполняемыми. После код может быть скомпонован в исполняемый файл. Этот процесс на языке ассемблера называется линковкой. Объектные файлы в зависимости от операционной системы обычно хранятся в формате контейнера (при котором различные данные содержатся в одном файле), таком как Executable and Linkable Format (ELF) для Unix-подобных систем или Portable Executable (PE) для Windows. Это придает структуру машинному коду, разделяя его на секции, такие как .text (выполняемый код), .data (инициализированные глобальные и статические переменные) и .rodata (данные только для чтения, такие как постоянные и строки).<br><br>

Исполняемые файлы обычно включают в себя среду выполнения, которая реализует функции языка программирования и компилятора среды выполнения (такие как планирование, обработка исключений, вызов статических конструкторов и деструкторов и т. д.) и взаимодействие с операционной системой, в частности, передача аргументов, окружения и кода возврата, вместе с другими функциями при запуске и завершении программы, которые не были указаны программистом, но представляющие ценность для последующей работы, такие как исполнение ресурсов. В Cи это делается путем линковки компоновщиком объектного файла crt0 в исполняемый файл, который содержит точку исполнения, выполняет настройку и завершает работу с помощью вызова библиотеки среды выполнения.<br><br>

Таким образом, исполняемые файлы обычно содержат дополнительный машинный код, который генерируется компилятором определённым образом из исходного кода. Это в некоторых случаях желательно пропустить, например, для разработки встроенных систем или просто для понимания того, как работают компиляция, линковка и загрузка. В Cи пропустить стандартную среду выполнения можно с помощью указания сценария компоновщика напрямую, к примеру, вызвать main функцию для запуска программы и возвратить статус выхода ядру.<br><br>
     </p>
     
     </li>
     <li>Исполнение
     <p>
     Для выполнения операционной системой, прошивкой или загрузчиком, исполняемый файл должен соответствовать бинарному интерфейсу приложений (ABI). В простых интерфейсах файл выполняется путем загрузки в память, перехода (прыжка) к началу адресного пространства и выполнения оттуда. В более сложных интерфейсах исполняемые файлы имеют дополнительные данные, определяющие отдельную точку входа. Например, в ELF точка входа указывается в заголовке e_entry, который указывает (виртуальный) адрес памяти, с которого следует начать выполнение. В GCC вход устанавливается компоновщиком с помощью символа _start.
     
     </p>
     
     </li>
     
     </ul>
     </div>
     `


  }else if(id == mas[2]){
                  
 document.getElementById("p").innerHTML = 
 `
  <div class = "radio_playlist1">
  
  <ul>Исходный код<br>
  
  <li>Исходный код
  
  <p>
Исхо́дный код (также исхо́дный текст)  —<br> текст компьютерной программы на каком-либо языке программирования или языке разметки, который может быть прочтён человеком. В обобщённом смысле — любые входные данные для транслятора. Исходный код транслируется в исполняемый код целиком до запуска программы при помощи компилятора или может исполняться сразу при помощи интерпретатора.<!--br><br-->
  
  
  
  </p>
  
  </li>
  <li>Назначение
  
  <p>
  Исходный код либо используется для получения объектного кода, либо сразу выполняется интерпретатором.<br><br>

Другое важное назначение исходного кода — описание программы. По тексту программы можно восстановить логику её поведения. Для облегчения понимания исходного кода используются комментарии. Существуют также инструментальные средства, позволяющие автоматически получать документацию по исходному коду — генераторы документации.
<br><br>
Кроме того, исходный код имеет и другие применения. Он может использоваться как инструмент обучения; начинающим программистам бывает полезно исследовать существующий исходный код для изучения технологии и методологии программирования. Он также используется как инструмент общения между опытными программистами благодаря своей лаконичной и недвусмысленной природе. Совместное использование кода разработчиками часто упоминается как фактор, способствующий улучшению опыта программистов.<br><br>

Программисты часто переносят исходный код (в виде модулей, в имеющемся виде или с адаптацией) из одного проекта в другой. Это называется повторным использованием кода.
<br><br>
Исходный код — важнейший компонент для процесса портирования программного обеспечения на другие платформы. Без исходного кода какой-либо части ПО портирование либо слишком сложно, либо вообще невозможно.<br><br>
  
  
  
  </p>
  
  </li>
  <li>Организация
  
  <p>
  Исходный код некоторой части ПО (модуля, компонента) может состоять из одного или нескольких файлов. Код программы не обязательно пишется только на одном языке программирования. Например, часто программы, написанные на языке Си, из соображений оптимизации содержат вставки кода на языке ассемблера. Также возможны ситуации, когда некоторые компоненты или части программы пишутся на различных языках, с последующей сборкой в единый исполняемый модуль при помощи технологии, известной как компоновка библиотек (library linking).<br><br>

Сложное программное обеспечение при сборке требует использования десятков или даже сотен файлов с исходным кодом. В таких случаях для упрощения сборки обычно используются файлы проектов, содержащие описание зависимостей между файлами с исходным кодом и описывающие процесс сборки. Эти файлы также могут содержать параметры для компилятора и среды проектирования. Для разных сред проектирования могут применяться разные файлы проекта, причём в некоторых средах эти файлы могут быть в текстовом формате, пригодном для непосредственного редактирования программистом с помощью универсальных текстовых редакторов, в других средах поддерживаются специальные форматы, а создание и изменения файлов производится с помощью специальных инструментальных программ. Файлы проектов обычно включают в понятие «исходный код». Часто под исходным кодом подразумевают и файлы ресурсов, содержащие различные данные, например, графические изображения, нужные для сборки программы.<br><br>

Для облегчения работы с исходным кодом и для совместной работы над кодом командой программистов используются системы управления версиями.<br><br>
  
  </p>
  
  
  
  </li>
  <li>Качество
  
  <p>
  В отличие от человека, для компьютера нет «хорошо написанного» или «плохо написанного» кода. Но то, как написан код, может сильно влиять на процесс сопровождения ПО. О качестве исходного кода можно судить по следующим параметрам:<br><br>

# читаемость кода (в том числе наличие комментариев к коду);<br><br>
# лёгкость в поддержке, тестировании, отладке и устранении ошибок, модификации и портировании;<br><br>
# экономное использование ресурсов: памяти, процессора, дискового пространства;<br><br>
# отсутствие замечаний, выводимых компилятором;<br><br>
# отсутствие «мусора» — неиспользуемых переменных, недостижимых блоков кода, ненужных устаревших комментариев и т. д.;<br><br>
# адекватная обработка ошибок;<br><br>
# возможность интернационализации интерфейса.<br><br>
  </p>
  
  </li>
  
  <li>Неисполняемый исходный код
  
  <p>
  Копилефтные лицензии для свободного ПО требуют распространения исходного кода. Эти лицензии часто используются также для работ, не являющихся программами — например, документации, изображений, файлов данных для компьютерных игр.<br><br>

  В таких случаях исходным кодом считается форма данной работы, предпочтительная для её редактирования. В лицензиях, предназначенных не только для ПО, она также может называться версией в «прозрачном формате». Это может быть, например:<br><br>
  
  # для файла, сжатого с потерей данных — версия без потерь;<br><br>
  # для рендера векторного изображения или трёхмерной модели — соответственно, векторная версия и модель;<br><br>
  # для изображения текста — такой же текст в текстовом формате;<br><br>
  # для музыки — файл во внутреннем формате музыкального редактора;<br><br>
  и наконец, сам файл, если он удовлетворяет указанным условиям, либо если более удобной версии просто не существовало.

  
  </p>
  
  </li>
  
  
  
  </ul>
  
  
  
  
  
  </div>   
     
     
     
`             
                  
   }else if(id == mas[3]){

                  

 document.getElementById("p").innerHTML = 
 `
  <div class = "radio_playlist1">
  
  <ul> Создание программ<br>
  
  <li> Создание программ
  
  <p>
  
  Чаще всего образ программы хранится в виде исполняемого модуля (отдельного файла или группы файлов). Из этого образа, находящегося, как правило, на диске, исполняемая программа в оперативной памяти может быть построена программным загрузчиком.<br><br>

В системном программировании программой называются данные, которые используются процессором как инструкции по управлению компьютерной системой. В состав программы может входить как машинный код, исполняемый процессором для достижения некоторой цели, так и необходимые для этого данные. Отличительной особенностью программы является её нахождение в памяти и исполнение процессором.<br><br>

Процесс разработки программного обеспечения состоит из нескольких этапов, из которых в узком смысле лишь непосредственное создание программного кода носит название «программирование». В широком смысле под программированием часто подразумевается весь процесс разработки ПО, а людей, занимающихся этим видом деятельности, называют программистами.<br><br>

Запись исходных текстов программ при помощи языков программирования облегчает понимание и редактирование человеком. Этому, в частности, помогают комментарии, допустимые в синтаксисе большинства языков. Для выполнения на компьютере готовый текст программы преобразуется (компилируется) в машинный код.<br><br>

Некоторые языки программирования позволяют обходиться без предварительной компиляции программы и переводят её в инструкции машинного кода непосредственно во время исполнения. Этот процесс называется динамической компиляцией, и он позволяет добиться большей переносимости программ между разными аппаратными и программными платформами при сохранении многих плюсов компиляции.<br><br>

Интерпретируемые программы, для которых, как правило, не применяется процесс компиляции и которые интерпретируются операционной системой или специальными программами-интерпретаторами, называются скриптами или «сценариями».<br><br>

Исходные тексты компьютерных программ в большинстве языков программирования состоят из списка инструкций, точно описывающих заложенный алгоритм. Подобный подход в программировании называется императивным. Однако применяются и другие методологии программирования. Например, описание исходных и требуемых характеристик обрабатываемых данных и предоставление выбора подходящего алгоритма решения специализированной программе-интерпретатору — такой подход называется декларативным программированием. К декларативному программированию относятся функциональное и логическое, а также менее распространённые виды программирования.<br><br>

Программы могут создаваться в текстовом виде и визуально. В первом случае исходный код набирается вручную, во втором функциональность программы задаётся с помощью элементов графического интерфейса пользователя, а текст программы генерируется автоматически и может быть как доступен для изменения вручную, так и полностью скрыт от программиста.<br><br>
  
  
  </p>
  
  </li>
  
  <li>Хранение и выполнение

  <p>
  До момента, когда пользователь компьютера явно или неявно выдаст запрос на выполнение компьютерной программы, она обычно хранится в энергонезависимой памяти. При получении такого запроса программа посредством другой компьютерной программы, называющейся операционной системой, загружается в память с произвольным доступом, откуда её непосредственно может выполнять центральный процессор. После этого центральный процессор выполняет программу, инструкция за инструкцией, до её завершения. Выполняющаяся программа называется процессом. Завершение программы происходит либо по достижении её последней инструкции (обычно передающей управление операционной системе), либо по ошибке, программной или аппаратной.<br><br>
  Одновременное выполнение<br><br>
  Многие операционные системы поддерживают механизм многозадачности, который позволяет создать эффект одновременной работы нескольких компьютерных программ на одном компьютере. Операционные системы могут выполнять несколько программ, используя диспетчер операционной системы — программный механизм для переключения процессов, выполняемых процессором. Хотя в каждый момент времени выполняется только одна программа, при достаточно частом переключении пользователь может взаимодействовать со всеми программами во время их работы. Современные многопроцессорные компьютеры или компьютеры с многоядерными процессорами поддерживают одновременное выполнение нескольких программ аппаратно.<br><br>

Фрагменты кода одной и той же компьютерной программы могут одновременно выполняться с помощью потоков выполнения. Существуют многопоточные процессоры, специально оптимизированные для выполнения нескольких потоков.<br><br>
Самомодифицирующиеся программы<br><br>
Считается, что выполняющаяся компьютерная программа отличается от данных, которые она обрабатывает. Однако это отличие размывается, когда компьютерная программа модифицирует сама себя. Модифицированная компьютерная программа затем выполняется как часть исходной программы. Самомодификация кода возможна в программах, написанных в машинном коде, на ассемблере, Лиспе, Си, Коболе, ПЛ/1 и Прологе.
</p>
  
  
  </li>
  <li>Использование программ
  <p>
  Большинство пользователей компьютеров использует программы, предназначенные для выполнения конкретных прикладных задач, таких, как подготовка и оформление документов, математические вычисления, обработка изображений и т. п. Соответствующие программные средства называют прикладными программами или прикладным программным обеспечением. Управление компонентами вычислительной системы и формирование среды для функционирования прикладных программ берёт на себя системное программное обеспечение, наиболее важной составляющей которого является операционная система.
  
  
  </p>
  
 </li>
  
  
  
  
  </ul>
  
  
  
  
  
  </div>   
     
     
     
`             
                  
   }else if(id == mas[4]){

                  

 document.getElementById("p").innerHTML = 
 `
  <div class = "radio_playlist1">
  
  <ul>Компиляция программы
  
  <li>Компилятор 
  
  <p>
  Компиля́тор —<br><br> программа, переводящая написанный на языке программирования текст в набор машинных кодов
  
  
  
  </p>
  
  </li>
  <li>Компиляция
  
  <p>
  Компиля́ция —<br><br> сборка программы, включающая:<br><br>

# трансляцию всех модулей программы, написанных на одном или нескольких исходных языках программирования высокого уровня и/или языке ассемблера, в эквивалентные программные модули на низкоуровневом языке, близком машинному коду (абсолютный код, объектный модуль, иногда на язык ассемблера) или непосредственно на машинном языке или ином двоичнокодовом низкоуровневом командном языке;<br><br>
# последующую сборку исполняемой машинной программы, в том числе вставка в программу кода всех функций, импортируемых из статических библиотек и/или генерация кода запроса к ОС на загрузку динамических библиотек, из которых программой функции будут вызываться.<br><br>
Если компилятор генерирует исполняемую машинную программу на машинном языке, то такая программа непосредственно исполняется физической программируемой машиной (например компьютером). В других случаях исполняемая машинная программа выполняется соответствующей виртуальной машиной.<br><br>

Входная информация для компилятора есть:<br><br>

# на фазе трансляции: исходный код программы, являющийся описанием алгоритма или программы на предметно-ориентированном языке программирования;<br><br>
# на фазе компоновки: сгенерированные на фазе трансляции файлы объектных кодов модулей программы, а также файлы объектных кодов статических библиотек и данные об используемых динамических библиотеках.<br><br>
На выходе компилятора — эквивалентное описание алгоритма на машинно-ориентированном языке (объектный код, байт-код).
  
  </p>
  
  </li>
    <li>Компили́ровать

  <p>
  Компили́ровать —<br><br> проводить сборку машинной программы, включая:<br><br>

# трансляцию с предметно-ориентированного языка на машинно-ориентированный язык,<br><br>
# компоновка исполняемой машинно-ориентированной программы из сгенерированных на фазе трансляции объектных модулей — модулей, содержащих части кода программы на машинно-ориентированного кода программы.<br><br>
Довольно часто компиляторы с языков высокого уровня выполняют лишь трансляцию исходного кода, компоновку же поручая внешнему компоновщику, — компоновщику, представляющему самостоятельную программу, вызываемую компилятором как внешняя подпрограмма. Вследствие этого компилятор многие считают разновидность транслятора, что неверно...<br><br>
  </p>
  
  </li>
    <li>Виды компиляторов
  
  <p>
 # Векторизующий. Базируется на трансляторе, транслирующем исходный код в машинный код компьютеров, оснащённых векторным процессором.<br><br>
# Гибкий. Сконструирован по модульному принципу, управляется таблицами и запрограммирован на языке высокого уровня или реализован с помощью компилятора компиляторов.<br><br>
# Диалоговый. См.: диалоговый транслятор.<br><br>
# Инкрементальный. Пересобирает программу, заново транслируя только изменённые фрагменты программы без перетрансляции всей программы.
<br><br>
# Интерпретирующий (пошаговый). Последовательно выполняет независимую компиляцию каждого отдельного оператора (команды) исходной программы.<br><br>
# Компилятор компиляторов. Транслятор, воспринимающий формальное описание языка программирования и генерирующий компилятор для этого языка.<br><br>
# Отладочный. Устраняет отдельные виды синтаксических ошибок.<br><br>
# Резидентный. Постоянно находится в оперативной памяти и доступен для повторного использования многими задачами.<br><br>
# Самокомпилируемый. Написан на том же языке программирования, с которого осуществляется трансляция.<br><br>
# Универсальный. Основан на формальном описании синтаксиса и семантики входного языка.<br><br> Составными частями такого компилятора являются: ядро, синтаксический и семантический загрузчики.<br><br>
Также все компиляторы условно можно разделить на две группы:<br><br>

Компиляторы с конкретных языков программирования. (Примеры: GCC, gnat, clang, xcode, gfortran.)<br><br>
Компиляторы как системы сборки программ. Таковы например довольно распространенная в UNIX- и Linux-системах система Makefile и распространенная в Windows-системах cmake. Работа последних (например в Makefile) очень часто управляется встроенным входным интерпретируемым языком, на котором и прописывается порядок самой компиляции программы.
  
  </p>
  
  </li>
    <li>Виды компиляции

  

  <p>
# Пакетная. Компиляция нескольких исходных модулей в одном задании.<br><br>
# Построчная. Машинный код порождается и затем исполняется для каждой завершённой грамматической конструкции языка. Внешне воспринимается как интерпретация, но имеет иное устройство.<br><br>
# Условная. На фазе трансляции результат трансляции зависит от условий, прописанных в исходном транслируемом тексте программы директивами компилятора. (Яркий пример — работа препроцессора языка С и производных от него.) Так, в зависимости от значения некой константы некая транслятор заданную часть транслируемого исходного текста программы транслирует или пропускает (игнорирует).
  
  </p>
  
  </li>
  <li>Структура компилятора

   <p>
   Процесс компиляции состоит из следующих этапов:<br><br>

# Трансляция программы — трансляция всех или только изменённых модулей исходной программы.
<br><br>
# Компоновка машинно-ориентированной программы.
<br><br>
Структурные реализации компилятора могут быть следующими:<br><br>

# И транслятор, и компоновщик могут целиком входить в состав компилятора как исполняемые программы.<br><br>
# Компилятор сам выполняет лишь трансляцию компилируемой программы, компоновка же программы выполняется вызываемой компилятором отдельной программой-компоновщиком. Практически все современные компиляторы построены по такой схеме.<br><br>
# Пакет программ, включающий в себя трансляторы с разных языков программирования и компоновщики.<br><br>
По первой схеме строились самые первые компиляторы, — для современных компиляторов такая схема построения нехарактерна.<br><br>

По второй схеме построены все без исключения компиляторы с языков высокого уровня. Любой такой компилятор сам выполняет только трансляцию и далее вызывает компоновщик как внешнюю подпрограмму, который и компонует машинно-ориентированную программу. Такая схема построения легко позволяет компилятору работать и в режиме транслятора с соответствующего языка программирования. Это обстоятельство нередко служит поводом считать компилятор разновидностью транслятора, что естественно неверно, — все современные компиляторы такого типа все же выполняют компоновку, пусть и силами вызываемого компилятором внешнего компоновщика, тогда как транслятор сам никогда не выполняет вызов внешнего компоновщика. Но это же обстоятельство позволяет компилятору с одного языка программирования на фазе компоновки включать в программу написанную на одном языке программирования функции-подпрограммы из уже оттранслированных соответствующим транслятором/компилятором, написанные на ином языке программирования. Так в программу на C/C++ можно вставлять функции написанные например на Pascal или Fortran. Аналогично и напротив написанная на C/C++ функции могут быть вставлены в Pascal- или Fortran-программу соответственно. Это было бы невозможно без поддержки многими современными компиляторами генерации кода вызова процедур (функций) в соответствии с соглашениями иных языков программирования. Например современные компиляторы с языка Pascal помимо организации вызова процедур/функций в стандарте самого Pascal поддерживают организацию вызова процедурой/функцией в соответствии с соглашениями языка C/C++. (Например чтобы на уровне машинного кода написанная на Pascal процедура/функция работала с входными параметрами в соответствии с соглашениями языка C/C++, — оператор объявления такой Pascal-процедуры/Pascal-функции должен содержать ключевое слово cdecl.)<br><br>

Наконец по третьей схеме построены компиляторы, представляющие собой целые системы, включающие в себя трансляторы с разных языков программирования и компоновщики. Также любой такой компилятор может использовать в качестве транслятора любой способный работать в режиме транслятора компилятор с конкретного языка высокого уровня. Естественно такой компилятор может компилировать программу, разные части исходного текста которой написаны на разных языках программирования. Нередко такие компиляторы управляются встроенным интерпретатором того или иного командного языка. Яркий пример таких компиляторов — имеющийся во всех UNIX-системах (в частности в Linux) компилятор make.<br><br>

Трансляция программы как неотъемлемая составляющая компиляции включает в себя:<br><br>

# Лексический анализ. На этом этапе последовательность символов исходного файла преобразуется в последовательность лексем.<br><br>
# Синтаксический (грамматический) анализ. Последовательность лексем преобразуется в древо разбора.<br><br>
# Семантический анализ. На этой фазе древо разбора обрабатывается с целью установления его семантики (смысла) — например, привязка идентификаторов к их объявлениям, типам данных, проверка совместимости, определение типов выражений и т. д. Результат обычно называется «промежуточным представлением/кодом», и может быть дополненным древом разбора, новым деревом, абстрактным набором команд или чем-то ещё, удобным для дальнейшей обработки.<br><br>
# Оптимизация. Выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла. Оптимизация может быть на разных уровнях и этапах — например, над промежуточным кодом или над конечным машинным кодом.<br><br>
# Генерация кода. Из промежуточного представления порождается код на целевом машинно-ориентированном языке.
  
  </p>
  
  </li>
  <li>Генерация машинного кода

<p>
  Большинство компиляторов переводит программу с некоторого высокоуровневого языка программирования в машинный код, который может быть непосредственно выполнен физическим процессором. Как правило, этот код также ориентирован на исполнение в среде конкретной операционной системы, поскольку использует предоставляемые ею возможности (системные вызовы, библиотеки функций). Архитектура (набор программно-аппаратных средств), для которой компилируется (собирается) машинно-ориентированная программа, называется целевой машиной.<br><br>

Результат компиляции — исполнимый программный модуль — обладает максимально возможной производительностью, однако привязан к конкретной операционной системе (семейству или подсемейству ОС) и процессору (семейству процессоров) и не будет работать на других.
<br><br>
Для каждой целевой машины (IBM, Apple, Sun, Эльбрус и т. д.) и каждой операционной системы или семейства операционных систем, работающих на целевой машине, требуется написание своего компилятора. Существуют также так называемые кросс-компиляторы, позволяющие на одной машине и в среде одной ОС генерировать код, предназначенный для выполнения на другой целевой машине и/или в среде другой ОС. Кроме того, компиляторы могут оптимизировать код под разные модели из одного семейства процессоров (путём поддержки специфичных для этих моделей особенностей или расширений наборов команд). Например, код, скомпилированный под процессоры семейства Pentium, может учитывать особенности распараллеливания инструкций и использовать их специфичные расширения — MMX, SSE и т. п.
<br><br>
Некоторые компиляторы переводят программу с языка высокого уровня не прямо в машинный код, а на язык ассемблера. (Пример: PureBasic, транслирующий бейсик-код в ассемблер FASM.) Это делается для упрощения части компилятора, отвечающей за генерацию кода, и повышения его переносимости (задача окончательной генерации кода и привязки его к требуемой целевой платформе перекладывается на ассемблер), либо для возможности контроля и исправления результата компиляции (в том числе ручной оптимизации) программистом.
</p>
  
</li>
<li>Генерация байт-кода

<p>
  Результатом работы компилятора может быть программа на специально созданном низкоуровневом языке двоично-кодовых команд, выполняемых виртуальной машиной. Такой язык называется псевдокодом или байт-кодом. Как правило, он не есть машинный код какого-либо компьютера и программы на нём могут исполняться на различных архитектурах, где имеется соответствующая виртуальная машина, но в некоторых случаях создаются аппаратные платформы, напрямую выполняющие псевдокод какого-либо языка. Например, псевдокод языка Java называется байт-кодом Java и выполняется в Java Virtual Machine, для его прямого исполнения была создана спецификация процессора picoJava. Для платформы .NET Framework псевдокод называется Common Intermediate Language (CIL), а среда исполнения — Common Language Runtime (CLR).
<br><br>
Некоторые реализации интерпретируемых языков высокого уровня (например, Perl) используют байт-код для оптимизации исполнения: затратные этапы синтаксического анализа и преобразование текста программы в байт-код выполняются один раз при загрузке, затем соответствующий код может многократно использоваться без перекомпиляции.
</p>
  
</li>
<li>Динамическая компиляция

<p>
 Из-за необходимости интерпретации байт-код выполняется значительно медленнее машинного кода сравнимой функциональности, однако он более переносим (не зависит от операционной системы и модели процессора). Чтобы ускорить выполнение байт-кода, используется динамическая компиляция, когда виртуальная машина транслирует псевдокод в машинный код непосредственно перед его первым исполнением (и при повторных обращениях к коду исполняется уже скомпилированный вариант).
<br><br>
Наиболее популярной разновидностью динамической компиляции является JIT. Другой разновидностью является инкрементальная компиляция[en].
<br><br>
CIL-код также компилируется в код целевой машины JIT-компилятором, а библиотеки .NET Framework компилируются заранее. 
</p>
  
</li>
<li>Трансляция байт-кода в машинный код

<p>
Трансляция байт-кода в машинный код специальным транслятором байт-кода как указано выше неотъемлемая фаза динамической компиляции. Но трансляция байт-кода применима и для простого преобразования программы на байт-коде в эквивалентную программу на машинном языке. В машинный код может транслироваться как заранее скомпилированный байт-код. Но также трансляция байт-кода в машинный код может выполняться компилятором байт-кода сразу следом за компиляцией байт-кода. Практически всегда в последнем случае трансляция байт-кода выполняется внешним транслятором, вызываемым компилятором байт-кода.
<br><br>
Декомпиляция<br><br>
Существуют программы, которые решают обратную задачу — перевод программы с низкоуровневого языка на высокоуровневый. Этот процесс называют декомпиляцией, а такие программы — декомпиляторами. Но поскольку компиляция — это процесс с потерями, точно восстановить исходный код, скажем, на C++, в общем случае невозможно. Более эффективно декомпилируются программы в байт-кодах — например, существует довольно надёжный декомпилятор для Flash. Разновидностью декомпиляции является дизассемблирование машинного кода в код на языке ассемблера, который почти всегда благополучно выполняется (при этом сложность может представлять самомодифицирующийся код или код, в котором собственно код и данные не разделены). Связано это с тем, что между кодами машинных команд и командами ассемблера имеется практически взаимно-однозначное соответствие.
</p>

</li>
<li>Раздельная компиляция

<p>
Раздельная компиляция (англ. separate compilation) — трансляция частей программы по отдельности с последующим объединением их компоновщиком в единый загрузочный модуль.
<br><br>
Исторически особенностью компилятора, отражённой в его названии (англ. compile — собирать вместе, составлять), являлось то, что он производил как трансляцию, так и компоновку, при этом компилятор мог порождать сразу машинный код. Однако позже, с ростом сложности и размера программ (и увеличением времени, затрачиваемого на перекомпиляцию), возникла необходимость разделять программы на части и выделять библиотеки, которые можно компилировать независимо друг от друга. В процессе трансляции программы сам компилятор или вызываемый компилятором транслятор порождает объектный модуль, содержащий дополнительную информацию, которая потом — в процессе компоновки частей в исполнимый модуль — используется для связывания и разрешения ссылок между частями программы. Раздельная компиляция также позволяет писать разные части исходного текста программы на разных языках программирования.
<br><br>
Появление раздельной компиляции и выделение компоновки как отдельной стадии произошло значительно позже создания компиляторов. В связи с этим вместо термина «компилятор» иногда используют термин «транслятор» как его синоним: либо в старой литературе, либо когда хотят подчеркнуть его способность переводить программу в машинный код (и наоборот, используют термин «компилятор» для подчёркивания способности собирать из многих файлов один). Вот только использование в таком контексте терминов «компилятор» и «транслятор» неправильно. Даже если компилятор выполняет трансляцию программы самостоятельно, поручая компоновку вызываемой внешней программе-компоновщику, такой компилятор не может считаться разновидностью транслятора, — транслятор выполняет трансляцию исходной программы и только. И уж тем более не являются трансляторами компиляторы вроде системной утилиты-компилятора make, имеющейся во всех UNIX-системах.
<br><br>
Собственно утилита make — яркий пример довольно удачной реализации раздельной компиляции. Работа утилиты make управляется сценарием на интерпретируемым утилитой входном языке, известном как makefile, содержащемся в задаваемом при запуске утилиты входном текстовом файле. Сама утилита не выполняет ни трансляцию, ни компоновку — де-факто утилита make функционирует как диспетчер процесса компиляции, организующий компиляцию программы в соответствии с заданным сценарием. В частности в ходе компиляции целевой программы утилита make вызывает трансляторы с языков программирования, транслирующие разные части исходной программы в объектный код, и уже после этого вызывается тот или иной компоновщик, компонующий конечный исполняемый программный или библиотечный программный модуль. При этом разные части программы, оформляемые в виде отдельных файлов исходного текста, могут быть написаны как на одном языке программирования, так и на разных языках программирования. В процессе перекомпиляции программы транслируются только изменённые части-файлы исходного текста программы, вследствие чего длительность перекомпиляции программы значительно (порой на порядок) сокращается.
<br><br>
История<br><br>
На заре развития компьютеров первые компиляторы (трансляторы) называли «программирующими программами» (так как в тот момент программой считался только машинный код, а «программирующая программа» была способна из человеческого текста сделать машинный код, то есть запрограммировать ЭВМ).

</p>

</li>
<!--li>

<p>

</p>

</li-->
  
</ul>
  
  
  
  
  
  </div>   
     
     
     
`             
                  
   }else if(id == mas[5]){



                  

 document.getElementById("p").innerHTML = 
 `
  <div class = "radio_playlist1">
  
  <ul>Объектный модуль/файл
  
  <li>Объектный модуль/файл
  
  <p>
  Объе́ктный мо́дуль <br><br> (также — объектный файл, англ. object file) — файл с промежуточным представлением отдельного модуля программы, полученный в результате обработки исходного кода компилятором. Объектный файл содержит в себе особым образом подготовленный код (часто называемый двоичным или бинарным), который может быть объединён с другими объектными файлами при помощи редактора связей (компоновщика) для получения готового исполнимого модуля либо библиотеки.
<br><br>
Объектные файлы представляют собой блоки машинного кода и данных с неопределенными адресами ссылок на данные и процедуры в других объектных модулях, а также список своих процедур и данных. Компоновщик собирает код и данные каждого объектного модуля в итоговую программу, вычисляет и заполняет адреса перекрестных ссылок между модулями. Связывание со статическими библиотеками выполняется редактором связей или компоновщиком (который может представлять собой отдельную программу или быть частью компилятора), а с операционной системой и динамическими библиотеками связывание выполняется при исполнении программы, после её загрузки в память.
<br><br>
Программист генерирует объектный код с помощью компилятора или ассемблера. Например, в Linux компилятор GNU Compiler Collection будет генерировать файлы с расширением .o, которые используют формат ELF. При компиляции в Windows создаются файлы с расширением .obj, использующие формат COFF. Затем компоновщик используется для объединения объектного кода в одну исполняемую программу или библиотеку, при необходимости извлекая предварительно скомпилированные системные библиотеки.
<br><br>
Существует множество различных форматов объектных файлов; изначально у каждого типа компьютеров был свой уникальный формат, но с появлением Unix и других портативных операционных систем некоторые форматы, такие как ELF и COFF, были определены и использовались в разных типах систем. Один и тот же формат может использоваться как для ввода, так и для вывода компоновщика и, таким образом, в качестве формата библиотеки и исполняемого файла. Некоторые форматы могут содержать машинный код для разных процессоров, при этом правильный вариант выбирается операционной системой при загрузке программы.
  
  
  
  </p>
  
  </li>
  
  
  
  
  
  </ul>
  
  
  
  
  
  </div>   
     
     
     
`             
                  
   }else if(id == mas[6]){



                  

 document.getElementById("p").innerHTML = 
 `
  <div class = "radio_playlist1">
  
  <ul>Компоновщик
  
  <li>Компоновщик
  
  <p>
   (также редактор связей, от англ. link editor, linker) — инструментальная программа, которая производит компоновку («линковку»): принимает на вход один или несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.
 <br><br>
  Изначально, до появления динамических библиотек, загрузчики могли выполнять некоторые функции компоновщика, однако сейчас, чаще всего, загрузка программ выделяется в отдельный процесс.
<br><br>
Для связывания модулей компоновщик использует таблицы символов, созданные компилятором в каждом из объектных модулей. Эти таблицы могут содержать символы следующих типов:
<br><br>
# Определённые или экспортируемые имена — функции и переменные, определённые в данном модуле и предоставляемые для использования другим модулям;<br><br>
# Неопределённые или импортируемые имена — функции и переменные, на которые ссылается модуль, но не определяет их внутри себя;<br><br>
# Локальные — могут использоваться внутри объектного файла для упрощения процесса настройки адресов[en].<br><br>
Для большинства компиляторов один объектный файл является результатом компиляции одного файла с исходным кодом. Если программа собирается из нескольких объектных файлов, компоновщик собирает эти файлы в единый исполняемый файл, вычисляя и подставляя адреса вместо символов, в течение времени компоновки (статическая компоновка) или во время исполнения (динамическая компоновка).
<br><br>
Компоновщик может извлекать объектные файлы из специальных коллекций, называемых библиотеками. Если не все символы, на которые ссылаются пользовательские объектные файлы, определены, то компоновщик ищет их определения в библиотеках, которые пользователь подал ему на вход. Обычно одна или несколько системных библиотек используются компоновщиком по умолчанию. Когда объектный файл, в котором содержится определение какого-либо искомого символа, найден, компоновщик может включить его (файл) в исполняемый файл (в случае статической компоновки) или отложить это до момента запуска программы (в случае динамической компоновки).
<br><br>
Работа компоновщика заключается в том, чтобы в каждом модуле определить и связать ссылки на неопределённые имена. Для каждого импортируемого имени находится его определение в других модулях, упоминание имени заменяется на его адрес.
<br><br>
Компоновщик обычно не выполняет проверку типов и количества параметров процедур и функций. Если надо объединить объектные модули программ, написанные на языках со строгой типизацией, то необходимые проверки должны быть выполнены дополнительной утилитой перед запуском редактора связей.
  
  
  </p>
  
  </li>
  <li>
 
 <p>

 </p>
  
  </li>
  
  
  
  
  </ul>
  
  
  
  
  
  </div>   
     
     
     
`             
                  
   }else if(id == mas[7]){



                  

 document.getElementById("p").innerHTML = 
 `
  <div id = "radio_playlist1">
  
  <ul>Интерпретация исходного кода 
  
  <li>Интерпретатор
  
  <p>
 # Интерпрета́тор (англ. interpreter ıntə:'prıtə, от лат. interpretator — толкователь) — программа (разновидность транслятора), выполняющая интерпретацию.<br><br>

# Интерпрета́ция — построчный анализ, обработка и выполнение исходного кода программы или запроса, в отличие от компиляции, где весь текст программы, перед запуском анализируется и транслируется в машинный или байт-код без её выполнения.
  
  
  
  </p>
  
  </li>
  <li>История
  
  <p>
  Первым интерпретированным языком программирования высокого уровня был Lisp. Его интерпретатор был создан в 1958 году Стивом Расселом[en] на компьютере IBM 704. Рассел вдохновился работой Джона Маккарти и выяснил, что функция eval в Lisp может быть встроена в машинный код.
  </p>
  
  </li>
  
 <li>Типы интерпретаторов

  <p>
  # Простой интерпретатор анализирует и тут же выполняет (собственно интерпретация) программу покомандно или построчно по мере поступления её исходного кода на вход интерпретатора. Достоинством такого подхода является мгновенная реакция. Недостаток — такой интерпретатор обнаруживает ошибки в тексте программы только при попытке выполнения команды или строки с ошибкой.
<br><br>
# Интерпретатор компилирующего типа — это система из компилятора, переводящего исходный код программы в промежуточное представление, например, в байт-код или p-код, и собственно интерпретатора, который выполняет полученный промежуточный код (так называемая виртуальная машина). Достоинством таких систем является большее быстродействие выполнения программ за счёт выноса анализа исходного кода в отдельный, разовый проход, и минимизации этого анализа в интерпретаторе. Недостатки — большее требование к ресурсам и требование на корректность исходного кода. Применяется в таких языках, как Java, PHP, Tcl, Perl, REXX (сохраняется результат парсинга исходного кода), а также в различных СУБД.
<br><br>
В случае разделения интерпретатора компилирующего типа на компоненты получаются компилятор языка и простой интерпретатор с минимизированным анализом исходного кода. Причём исходный код для такого интерпретатора не обязательно должен иметь текстовый формат или быть байт-кодом, который понимает только данный интерпретатор, это может быть машинный код какой-то существующей аппаратной платформы. К примеру, виртуальные машины вроде QEMU, Bochs, VMware включают в себя интерпретаторы машинного кода процессоров семейства x86.
<br><br>
Некоторые интерпретаторы (например, для языков Лисп, Scheme, Python, Бейсик и других) могут работать в режиме диалога или так называемого цикла чтения-вычисления-печати (англ. read-eval-print loop, REPL). В таком режиме интерпретатор считывает законченную конструкцию языка (например, s-expression в языке Лисп), выполняет её, печатает результаты, после чего переходит к ожиданию ввода пользователем следующей конструкции.
<br><br>
Уникальным является язык Forth, который способен работать как в режиме интерпретации, так и компиляции входных данных, позволяя переключаться между этими режимами в произвольный момент, как во время трансляции исходного кода, так и во время работы программ.
<br><br>
Следует также отметить, что режимы интерпретации можно найти не только в программном, но и аппаратном обеспечении. Так, многие микропроцессоры интерпретируют машинный код с помощью встроенных микропрограмм, а процессоры семейства x86, начиная с Pentium (например, на архитектуре Intel P6), во время исполнения машинного кода предварительно транслируют его во внутренний формат (в последовательность микроопераций).
  </p>
  
  </li>
  <li>Алгоритм работы простого интерпретатора
  
  <p>
1. прочитать инструкцию;<br><br>
2. проанализировать инструкцию и определить соответствующие действия;<br><br>
3. выполнить соответствующие действия;<br><br>
4. если не достигнуто условие завершения программы, прочитать следующую инструкцию и перейти к пункту 2.
  </p>
  
  </li>
  <li>Достоинства и недостатки интерпретаторов
  
  <p>
  1. Достоинства<br><br>
# Большая переносимость интерпретируемых программ — программа будет работать на любой платформе, на которой реализован соответствующий интерпретатор.<br><br>
# Как правило, более совершенные и наглядные средства диагностики ошибок в исходных кодах.
<br><br>
# Меньшие размеры кода по сравнению с машинным кодом, полученным после обычных компиляторов.<br><br>
2. Недостатки<br><br>
# Интерпретируемая программа не может выполняться отдельно без программы-интерпретатора. Сам интерпретатор при этом может быть очень компактным.
# Интерпретируемая программа выполняется медленнее, поскольку промежуточный анализ исходного кода и планирование его выполнения требуют дополнительного времени в сравнении с непосредственным исполнением машинного кода, в который мог бы быть скомпилирован исходный код.<br><br>
# Практически отсутствует оптимизация кода, что приводит к дополнительным потерям в скорости работы интерпретируемых программ.
  </p>
  
  </li>
  <li>
  
  <p>
  
  </p>
  
  </li>
  </ul>
  
  
  
  
  
  </div>   
     
     
     
`             
                  
   }else if(id == mas[8]){



                  

 document.getElementById("p").innerHTML = 
 `
  <div class = "radio_playlist1">
  
  <ul>JIT-компиляция
  
  <li>JIT-компиляция
  
  <p>
  JIT-компиляция (англ. Just-in-Time, компиляция «точно в нужное время»), динамическая компиляция (англ. dynamic translation) — технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы. Таким образом достигается высокая скорость выполнения по сравнению с интерпретируемым байт-кодом (сравнимая с компилируемыми языками) за счёт увеличения потребления памяти (для хранения результатов компиляции) и затрат времени на компиляцию. Технология JIT базируется на двух более ранних идеях, касающихся среды выполнения: компиляции байт-кода и динамической компиляции.
<br><br>
Так как JIT-компиляция является, по сути, одной из форм динамической компиляции, она позволяет применять такие технологии, как адаптивная оптимизация и динамическая рекомпиляция. Благодаря этому JIT-компиляция может показывать лучшие результаты в плане производительности, чем статическая компиляция. Интерпретация и JIT-компиляция особенно хорошо подходят для динамических языков программирования, при этом среда исполнения справляется с поздним связыванием типов и гарантирует безопасность исполнения.
<br><br>
Проекты LLVM, GNU Lightning, libJIT (часть проекта DotGNU) и RPython (часть проекта PyPy) могут быть использованы для создания JIT-интерпретаторов любого скриптового языка.
  
  
  
  </p>
  
  </li>
  <li>Особенности реализации
  <p>
  JIT-компиляция может быть применена как ко всей программе, так и к её отдельным частям. Например, текстовый редактор может на лету компилировать регулярные выражения для более быстрого поиска по тексту. С AOT-компиляцией такое сделать не представляется возможным для случаев, когда данные предоставляются во время исполнения программы, а не в момент компиляции. JIT используется в реализациях Java (JRE), JavaScript, .NET Framework, в одной из реализаций Python — PyPy. Существующие наиболее распространённые интерпретаторы языков PHP, Ruby, Perl, Python и им подобных имеют ограниченные или неполные JIT.
<br><br>
Большинство реализаций JIT имеют последовательную структуру: сначала приложение компилируется в байт-код виртуальной машины среды исполнения (AOT-компиляция), а потом JIT компилирует байт-код непосредственно в машинный код. В итоге при запуске приложения тратится лишнее время, что впоследствии компенсируется более быстрой его работой.
  </p>
  </li>
    <li>Описание

  <p>
В языках, таких как Java, PHP, C#, Lua, Perl, GNU CLISP, исходный код транслируется в одно из промежуточных представлений, называемое байт-кодом. Байт-код не является машинным кодом какого-либо конкретного процессора и может переноситься на различные компьютерные архитектуры и исполняться точно так же. Байт-код интерпретируется (исполняется) виртуальной машиной. JIT читает байт-код из некоторых секторов (редко сразу из всех) и компилирует их в машинный код. Этим сектором может быть файл, функция или любой фрагмент кода. Единожды скомпилированный код может кэшироваться и в дальнейшем повторно использоваться без перекомпиляции.
<br><br>
Динамически компилируемая среда — это среда, в которой компилятор может вызываться приложением во время выполнения. Например, большинство реализаций Common Lisp содержат функцию compile, которая может создать функцию во время выполнения; в Python это функция eval. Это удобно для программиста, так как он может контролировать, какие части кода действительно подлежат компиляции. Также с помощью этого приёма можно компилировать динамически сгенерированный код, что в некоторых случаях приводит даже к лучшей производительности, чем реализация в статически скомпилированном коде. Однако стоит помнить, что подобные функции могут быть опасны, особенно когда данные передаются из недоверенных источников.
<br><br>
Основная цель использования JIT — достичь и превзойти производительность статической компиляции, сохраняя при этом преимущества динамической компиляции:
<br><br>
# Большинство тяжеловесных операций, таких как парсинг исходного кода и выполнение базовых оптимизаций, происходит во время компиляции (до развёртывания), в то время как компиляция в машинный код из байт-кода происходит быстрее, чем из исходного кода.<br><br>
# Байт-код более переносим (в отличие от машинного кода).<br><br>
# Среда может контролировать выполнение байт-кода после компиляции, поэтому приложение может быть запущено в песочнице (для нативных программ такая возможность тоже существует, но реализация данной технологии сложнее).<br><br>
# Компиляторы из байт-кода в машинный код легче в реализации, так как большинство работы по оптимизации уже было проделано компилятором.
<br><br>
JIT, как правило, эффективней, чем интерпретация кода. К тому же в некоторых случаях JIT может показывать большую производительность по сравнению со статической компиляцией за счёт оптимизаций, возможных только во время исполнения:<br><br>
1. Компиляция может осуществляться непосредственно для целевого процессора и операционной системы, на которой запущено приложение. Например, JIT может использовать векторные SSE2 расширения процессора, если он обнаружит их поддержку.<br><br>
2. Среда может собирать статистику о работающей программе и производить оптимизации с учётом этой информации. Некоторые статические компиляторы также могут принимать на вход информацию о предыдущих запусках приложения.<br><br>
3. Среда может делать глобальные оптимизации кода (например, встраивание библиотечных функций в код) без потери преимуществ динамической компиляции и без накладных расходов, присущих статическим компиляторам и компоновщикам.<br><br>
4. Более простое перестраивание кода для лучшего использования кэша.
  </p>
  </li>
    <li>Задержка при запуске, средства борьбы с ней

  <p>
Типичная причина задержки при запуске JIT-компилятора — расходы на загрузку среды и компиляцию приложения в машинный код. В общем случае, чем лучше и чем больше оптимизаций выполняет JIT, тем дольше получается задержка. Поэтому разработчикам JIT приходится искать компромисс между качеством генерируемого кода и временем запуска. Однако, часто оказывается так, что узким местом в процессе компиляции оказывается не сам процесс компиляции, а задержки системы ввода-вывода (так, например, rt.jar в Java Virtual Machine (JVM) имеет размер 40 МБ, и поиск метаданных в нём занимает достаточно большое количество времени).
<br><br>
Ещё одно средство оптимизации — компилировать только те участки приложения, которые используются чаще всего. Этот подход реализован в PyPy и HotSpot Java Virtual Machine компании Sun Microsystems.
<br><br>
В качестве эвристики может использоваться счётчик запусков участков приложения, размер байт-кода или детектор циклов.
<br><br>
Порой достаточно сложно найти правильный компромисс. Так, например, Sun’s Java Virtual Machine имеет два режима работы — клиент и сервер. В режиме клиента количество компиляций и оптимизаций минимально для более быстрого запуска, в то время как в режиме сервера достигается максимальная производительность, но из-за этого увеличивается время запуска.<br><br>
Ещё одна техника, называемая pre-JIT, компилирует код до запуска. Преимуществом данной техники является уменьшенное время запуска, в то же время недостатком является плохое качество скомпилированного кода по сравнению с runtime JIT.
  </p>
  </li>
    <li>История

  <p>
Самую первую реализацию JIT можно отнести к LISP, написанную McCarthy в 1960 году. В его книге Recursive functions of symbolic expressions and their computation by machine, Part I он упоминает функции, компилируемые во время выполнения, тем самым избавив от надобности вывода работы компилятора на перфокарты.
<br><br>
Другой ранний пример упоминания JIT можно отнести к Кену Томпсону, который в 1968 году впервые применил регулярные выражения для поиска подстрок в текстовом редакторе QED. Для ускорения алгоритма Томпсон реализовал компиляцию регулярных выражений в машинный код IBM 7094.
<br><br>
Метод получения скомпилированного кода был предложен Митчелом в 1970 году, когда он реализовал экспериментальный язык LC2.
<br><br>
Smalltalk (1983) был пионером в области JIT-технологий. Трансляция в машинный код выполнялась по требованию и кэшировалась для дальнейшего использования. Когда память кончалась, система могла удалить некоторую часть кэшированного кода из оперативной памяти и восстановить его, когда он снова потребуется. Язык программирования Self некоторое время был самой быстрой реализацией Smalltalk и работал всего лишь в два раза медленней C, будучи полностью объектно-ориентированным.
<br><br>
Self был заброшен Sun, но исследования продолжились в рамках языка Java. Термин «Just-in-time компиляция» был заимствован из производственного термина «Точно в срок» и популяризован Джеймсом Гослингом, использовавшим этот термин в 1993. В данный момент JIT используется почти во всех реализациях Java Virtual Machine.
<br><br>
Также большой интерес представляет диссертация, защищённая в 1994 году в Университете ETH (Швейцария, Цюрих) Михаэлем Францем «Динамическая кодогенерация — ключ к переносимому программному обеспечению» и реализованная им система Juice динамической кодогенерации из переносимого семантического дерева для языка Оберон. Система Juice предлагалась как плагин для интернет-браузеров.
  </p>
  </li>
 <li>Безопасность
 <p>
Так как JIT составляет исполняемый код из данных, возникает вопрос безопасности и возможных уязвимостей.
<br><br>
JIT компиляция включает в себя компиляцию исходного кода или байт-кода в машинный код и его выполнение. Как правило, результат записывается в память и исполняется сразу же, без промежуточного сохранения на диск или его вызов как отдельной программы. В современных архитектурах для повышения безопасности произвольные участки памяти не могут быть исполнены как машинный код (NX bit). Для корректного запуска регионы памяти должны быть предварительно помечены как исполняемые, при этом для большей безопасности флаг исполнения может ставиться только после снятия флага разрешения записи (Схема защиты W^X).
 </p>
 </li> 
  </ul>
  
  
  
  
  
  </div>   
     
     
     
`             
                  
   }else if(id == mas[9]){



                  

 document.getElementById("p").innerHTML = 
 `
  <div class = "radio_playlist1">
  
  <ul>Байт-код
  
  <li>Байт-код
  
  <p>
  Байт-код (байтко́д; англ. bytecode, также иногда p-код, p-code от portable code) — стандартное промежуточное представление[en], в которое может быть переведена компьютерная программа автоматическими средствами. По сравнению с исходным кодом, удобным для создания и чтения человеком, байт-код — это компактное представление программы, уже прошедшей синтаксический и семантический анализ. В нём в явном виде закодированы типы, области видимости и другие конструкции. С технической точки зрения байт-код представляет собой машинно-независимый код низкого уровня, генерируемый транслятором из исходного кода.
<br><br>
Многие современные языки программирования, особенно интерпретируемые, используют байт-код для облегчения и ускорения работы интерпретатора. Трансляция в байт-код является методом, промежуточным по эффективности между прямой интерпретацией и компиляцией в машинный код.
<br><br>
По форме байт-код похож на машинный код, но предназначен для исполнения не реальным процессором, а виртуальной машиной. В качестве виртуальной машины обычно выступает интерпретатор соответствующего языка программирования (иногда дополненный JIT- или AOT-компилятором). Спецификации байт-кода и исполняющих его виртуальных машин могут сильно различаться для разных языков: часто байт-код состоит из инструкций для стековой[en] виртуальной машины, однако могут использоваться и регистровые[en] машины. Тем не менее, большинство инструкций байт-кода обычно эквивалентны одной или нескольким командам ассемблера.
<br><br>
Байт-код называется так, потому что длина каждого кода операции традиционно составляет один байт. Каждая инструкция обычно представляет собой однобайтовый код операции (от 0 до 255), за которым могут следовать различные параметры, например, номер регистра или адрес в памяти.
  
  
  
  </p>
  
  </li>
  <li>Исполнение
  <p>
  Программа на байт-коде обычно выполняется интерпретатором байт-кода. Преимущество байт-кода в большей эффективности и портируемости, то есть один и тот же байт-код может исполняться на разных платформах и архитектурах, для которых реализован интерпретатор. То же самое преимущество дают непосредственно интерпретируемые языки, однако, поскольку байт-код обычно менее абстрактен и более компактен, чем исходный код, эффективность интерпретации байт-кода обычно выше, чем чистая интерпретация исходного кода или интерпретация АСД. Кроме того, интерпретатор байт-кода зачастую проще интерпретатора исходного кода и его проще перенести (портировать) на другую аппаратную платформу.
<br><br>
В высокопроизводительных реализациях виртуальных машин может применяться комбинация интерпретатора и JIT-компилятора, который во время исполнения программы транслирует часто используемые фрагменты байт-кода в машинный код, применяя при этом различные оптимизации. Вместо JIT-компиляции может применяться AOT-компилятор, транслирующий байт-код в машинный код предварительно, до исполнения.
<br><br>
В то же время возможно создание процессоров, для которых данный байт-код является непосредственно машинным кодом (такие экспериментальные процессоры создавались, например, для языков Java и Форт).
  </p>
  </li>
  <li>История
  <p>
  Среди первых систем, использовавших байт-код, были O-code для BCPL (1960-е), Smalltalk (1976), SIL (System Implementation Language) для языка Snobol-4 (1967), p-код (p-code, 1970-е, при участии Никлауса Вирта) для переносимых компиляторов языка программирования Pascal.
<br><br>
Варианты p-кода широко использовались в различных реализациях языка Pascal, например, в UCSD p-System (UCSD Pascal).
  </p>
  </li>
    <li>Применение

  <p>
К интерпретируемым языкам, использующим байт-код, относятся Perl, PHP (например Zend Engine), Ruby (начиная с версии 1.9), Python, Erlang и многие другие.
<br><br>
Широко распространённые платформы, использующие байт-код:
<br><br>
# Байт-код Java (стековая виртуальная машина), исполняемый различными виртуальными машинами Java. Платформа была создана компанией Sun для языка Java, но стала использоваться и для других языков; существуют десятки высокопроизводительных реализаций JVM, использующих JIT-компиляторы.<br><br>
# Существуют варианты трансляции Java в байт-код регистровых машин, например, в виртуальной машине Dalvik (с JIT-компиляцией) или при AOT-компиляции в ART.<br><br>
# Платформа Microsoft .NET использует стековый байт-код Intermediate Language (CIL, MSIL), исполняемый с помощью Common Language Runtime (CLR), создана Microsoft для C# и некоторых других языков.<br><br>
# Сценарный язык JavaScript выполняется различными высокопроизводительными «движками», в основном, встроенными в веб-браузеры, часто с возможностью JIT-оптимизации. Многие интерпретаторы построены с применением байт-кода, однако программы на Javascript распространяются в виде исходных кодов.<br><br>
# Сценарный язык ActionScript транслируется в стековый байт-код, распространяется в составе swf- и pdf-файлов, и выполняется виртуальными машинами в Adobe Flash и Adobe Acrobat.<br><br>
Компилятор Clipper создает исполняемый файл, в который включен байт-код, транслированный из исходного текста программы, и виртуальная машина, исполняющая этот байт-код.
<br><br>
Программы на Java обычно компилируются в class-файлы  (англ.)рус., содержащие байт-код Java. Эти универсальные файлы передаются на различные целевые машины.
<br><br>
В ранних реализациях Visual Basic (до версии 6) использовался высокоуровневый Microsoft p-code
<br><br>
Высокоуровневые p-коды и байт коды применялись в СУБД, некоторых реализациях Бейсика и Паскаля.
<br><br>
В стандарте открытых загрузчиков Open Firmware фирмы Sun Microsystems байт-код представляет операторы языка Форт.
  
  </p>
  </li>
  <li>Критика
  <p>
  Традиционно байт-код проектируется в стиле стековых виртуальных машин, что упрощает генерацию из AST, позволяет использовать более простую и компактную кодировку байт-кода, упростить интерпретатор и уменьшить количество машинного кода, требуемого для исполнения одной инструкции байт-кода. С другой стороны, такие варианты байт-кода для заданной программы содержат большее количество инструкций, чем байт-коды регистровых виртуальных машин, из-за чего интерпретатор должен совершить больше непрямых переходов, для которых плохо работает предсказание переходов. Байт-код для регистровых виртуальных машин имеет немного больший размер машинных кодов, однако количество инструкций по сравнению со стековым байт кодом примерно в два раза меньше, а интерпретатор — быстрее на десятки процентов. Также байт-код стековых машин сложнее для проведения оптимизаций (выражения становятся неявными, связанные инструкции не сгруппированы, выражения распределены по нескольким базовым блокам) и требует верификации корректности использования стека.
<br><br>
Ошибки верификации байт-кода стековых машин приводили к появлению множества экстремально опасных уязвимостей, в частности десятков в виртуальной машине AVM2, используемой в Adobe Flash для исполнения скриптов ActionScript и нескольких в ранних популярных системах исполнения Java (JVM)
<br><br>
В конце 2000-х — начале 2010-х авторы компиляторов V8 (для языка JavaScript, часто реализуемого через байт-код) и Dart усомнились в том, что промежуточные байткоды обязательны для быстрых и эффективных виртуальных машин. В этих проектах была реализована непосредственная JIT-компиляция (компиляция во время исполнения) из исходных кодов сразу в машинный код.
  </p>
  </li>
  
  </ul>
  
  
  
  
  
  </div>   
     
     
     
`             
                  
   }else if(id == mas[10]){



                  

 document.getElementById("p").innerHTML = 
 `
  <div id = "radio_playlist1">
  
  <ul>
  
  <il>
  
  <p>
  
  
  
  
  </p>
  
  </il>
  
  
  
  
  
  </ul>
  
  
  
  
  
  </div>   
     
     
     
`             
                  
   }
  }
 }